/*Implementation of algorithms used to compute a homography between two 
images */

#ifndef HOMOGRAPHY
#define HOMOGRAPHY

#include <iostream>
#include <fstream>
#include <vector>
#include <stdio.h>
#include <cstdlib>
#include <Eigen/Dense>
#include "preprocessing.hpp"
#include <math.h>
#include <algorithm>
#include <ctime>
#include <random>




//function prototypes
Eigen::Matrix<double,2,1> AlgebraicError(const Eigen::Matrix<double,9,1> & h, 
                                         const  Eigen::Matrix<double,4,1> & X);

                               
Eigen::Matrix<double,3,3> DLT(const Eigen::MatrixXd & X);

Eigen::Matrix<double,3,3> NormalizedDLT(const Eigen::MatrixXd & X);


Eigen::Matrix<double, 2, 4> AlgebraicErrorJacobian(const Eigen::Matrix<double,9,1> & h,
                                                   const Eigen::Matrix<double,4, 1> & X);


Eigen::Matrix<double, 4, 1> HSampsonError(const Eigen::Matrix<double,9,1> & h,
                                          const Eigen::Matrix<double,4, 1> & X);
                                         

Eigen::Matrix<double, 4, 9> HSampsonErrorJacobian(const Eigen::Matrix<double,9,1> & h,
                                                  const Eigen::Matrix<double,4, 1> & X);
                                                  
Eigen::MatrixXd HTotalSampsonError(const Eigen::Matrix<double,9,1> & h, const Eigen::MatrixXd & X);

Eigen::MatrixXd HTotalSampsonErrorJacobian(const Eigen::Matrix<double,9,1> & h, const Eigen::MatrixXd & X);

double HApproximateMSResidualError(const Eigen::Matrix<double,9,1> & h, const Eigen::MatrixXd & X);


Eigen::Matrix <double,3,3> HMinimizeApproximateMSResidualError(Eigen::Matrix<double,3,3> Hinit,
                                                               const Eigen::MatrixXd & X, int numIterations,
                                                               std::string fileName);

double EstimatedNoiseStandardDeviation(double MSResidualError, int n);

std::vector<int> HRetrieveInliersIndex(const Eigen::MatrixXd & X, const Eigen::Matrix<double,9,1> & h, double threshold);

Eigen::MatrixXd Retrieve(std::vector<int> v, const Eigen::MatrixXd & X);

std::vector<int> HRANSAC(const Eigen::MatrixXd & X, double p, double sigma, double epsilon);


                                         

//*********************************************************************
//Implementation of the functions
//*********************************************************************
Eigen::Matrix<double,2, 1> AlgebraicError(const Eigen::Matrix<double,9,1> & h, 
                                          const Eigen::Matrix<double,4,1> & X)
{
   //Function computes algebraic errror of a homography given a measurement 
   //                  X = (x,y,xprime,yprime) 
   // where (x,y) are coordinates of a point in the first image 
   // and (xprime, yprime) are the coordinates of a corresponding point in 
   // the second image. Furthermore
   //             h = (h1,h2,h3,...,h9)
   // are the entries of the homography matrix in row-major order.
   // 
   // See section 4.2.1 of "Multiple View Geometry", 2nd edition, Hartley 
   // and Zisserman  
	Eigen::Matrix<double,2,9> A;
	
	A << 0.0, 0.0, 0.0, -X(0), -X(1), -1.0, X(3)*X(0), X(3)*X(1), X(3),
		       X(0), X(1), 1.0, 0.0, 0.0, 0.0, -X(2)*X(0), -X(2)*X(1), -X(2);
		       
    return A*h;
}

           //*******************************************//

Eigen::Matrix<double,3,3> DLT(const Eigen::MatrixXd & X)
{
	
	//Function computes the homography generated by a set of correspondences
    // by using the Direct Linear Transformation algorithm
    //Input:
    //     _ X:= (N x 4) matrix of correspondences
    //Output:
    //     _ H:= (3 x 3) homography matrix 

            
    //Matrix A that defines the algebraic cost function
    int s = X.rows();
    Eigen::MatrixXd A(2*s,9); 
        	
    for (int i = 0; i < s; i++)
	{
	  //Append to block matrix
	  A.block<2,9>(2*i,0) << 0.0, 0.0, 0.0, -X(i,0), -X(i,1), -1.0, X(i,3)*X(i,0), X(i,3)*X(i,1), X(i,3),
		                     X(i,0), X(i,1), 1.0, 0.0, 0.0, 0.0, -X(i,2)*X(i,0), -X(i,2)*X(i,1), -X(i,2);     
	}
    
      
    //Computing the right singular vector corresponding to smallest 
    // singular value of A
    Eigen::JacobiSVD<Eigen::MatrixXd,1 > svd(A, Eigen::ComputeFullV);
    Eigen::MatrixXd h = svd.matrixV().col(8);
    
    //Reshaping 
    Eigen::Map<Eigen::MatrixXd> Ht(h.data(), 3,3);
    
          
    //Transposing
    Eigen::Matrix<double,3,3> H = Ht.transpose();
    
    return H;
   	
}	                                     
          //**************************************//

Eigen::Matrix<double,3,3> NormalizedDLT(const Eigen::MatrixXd & X)
{
	// Function computes homography after normalizinng the set of 
	// correspondences
	
	Eigen::MatrixXd Xnorm(X.rows(),4);
    Eigen::Matrix <double, 3, 3> T;
    Eigen::Matrix <double, 3, 3> Tprime;
    
    //Normalizing and storing generated similarity transformations
    Normalize(X, Xnorm, T, Tprime);
    
    //Computing normalized homography matrix
    Eigen::Matrix<double,3,3> Hnorm = DLT(Xnorm);
    
    //Denormalizing
    return (Tprime.inverse())* Hnorm* T;
}

     //***************************************//

Eigen::Matrix<double, 2, 4> AlgebraicErrorJacobian(const Eigen::Matrix<double,9,1> & h,
                                                   const Eigen::Matrix<double,4, 1> & X)
{ 
	// Function to compute the Jacobian for the Algebraic error
    // Input: 
    //       _ X:= (4 x 1)  a vector for a correspondence
    //       _ h:= (9 x1) vector representing the homography and which induces
    //            the cost function C_{H}(X). This cost function corresponds
    //            to the quadric in R^4 generated by the homography
    //            (See section 4.2.5 of "Multiple View Geometry", 
    //            2nd edition, Hartley and Zisserman. 
    //  
    // Output: 
    //        _J:= Jacobian of the cost function C_{H} with respect to X

	Eigen::Matrix<double,2,4> J;
	
	J << h(6)*X(3) - h(3), h(7)*X(3) - h(4), 0, h(6)*X(0) + h(7)*X(1) + h(8),
	     h(0) - h(6)*X(2), h(1) -h(7)*X(2), -(h(6)*X(0) + h(7)*X(1) + h(8)), 0;
	
	return J;
}



Eigen::Matrix<double, 4, 1> HSampsonError(const Eigen::Matrix<double,9,1> & h,
                                          const Eigen::Matrix<double,4, 1> & X)
{
	// Function to compute the Sampson error vector for a homography
    // See "Multiple-View Geometry" 2nd edition Section 4.2.6
    // Input:
    //      _X:= (4 x 1) vector of  a correspondence
    //      _h:= (9 x 1) vector for the homography
    // Output:
    //       (4 x 1) Sampson error vector
	
	Eigen::Matrix<double,2,1> Epsilon  = AlgebraicError(h,X); //algebraic error vector
	
	Eigen::Matrix<double, 2, 4> J  = AlgebraicErrorJacobian(h,X);
	
	return -J.transpose() * (J * J.transpose()).inverse() * Epsilon;
}


Eigen::Matrix<double, 4, 9> HSampsonErrorJacobian(const Eigen::Matrix<double,9,1> & h,
                                                  const Eigen::Matrix<double,4, 1> & X)           
{
  // Function computes the Jacobian of the Sampson error with respect to h
  // Input:
  //      _ X:= (4 x 1) vector of a correspondence
  //      _ h:= (9 x1) vector of a homography
  //Output:
 //       _ Grad: (4 x 9) Jacobian for Sampson error with respect to h
  Eigen::Matrix<double, 4, 9> Grad;
   
  // STL vector containing the derivative of J with respect to h
  std::vector<Eigen::Matrix<double, 2, 4> > DJ;
  
  DJ.reserve(9);
  
  DJ[0] << 0, 0, 0, 0,
	         1, 0, 0, 0;
  
  DJ[1] << 0, 0, 0, 0,
           0, 1, 0, 0;
   
   
  DJ[2] << 0, 0, 0, 0,
           0, 0, 0, 0;
           
  DJ[3] << -1, 0, 0, 0, 
            0, 0, 0, 0;
            
  DJ[4] << 0, -1, 0, 0, 
            0, 0, 0, 0;
            
  DJ[5] << 0, 0, 0, 0,
           0, 0, 0, 0;
   
   
  DJ[6] << X(3), 0, 0, X(0),
          -X(2), 0, -X(0), 0;
          
  DJ[7] << 0, X(3), 0, X(1),
          0, -X(2), -X(1), 0;
          
  DJ[8] << 0, 0, 0, 1,
           0, 0, -1, 0;
           
  Eigen::Matrix<double, 2, 4> J  = AlgebraicErrorJacobian(h,X);
  Eigen::Matrix<double, 2, 2>  B = (J * J.transpose()).inverse();
  Eigen::Matrix<double,2,9> A_point;
	
  A_point << 0.0, 0.0, 0.0, -X(0), -X(1), -1.0, X(3)*X(0), X(3)*X(1), X(3),
		     X(0), X(1), 1.0, 0.0, 0.0, 0.0, -X(2)*X(0), -X(2)*X(1), -X(2);
		     
  Grad  = -J.transpose() * B * A_point;
  
  for (int j = 0; j < 9; j++)
  {
	  Grad.col(j)  += (-DJ[j].transpose() 
	                  + J.transpose()*B * (DJ[j] *J.transpose() + J * DJ[j].transpose() ) )* B * A_point*h;
  }
  
  return Grad;
}

         //****************************************//
         
Eigen::MatrixXd HTotalSampsonError(const Eigen::Matrix<double,9,1> & h, const Eigen::MatrixXd & X)
{  
   // Function to compute the stacked error vector from Sampson approximation
	//Input:
	//      _ h:= (9 x 1) vector for homography matrix
	//      _ X:= (N x 4) matrix where each row is a correspondence
   // Output: 
   //        _totalError:= (4N x 1) vector made from concatenating the sampson 
   //                     error from each correspondence
   int s = X.rows();
   Eigen::MatrixXd totalError(4*s,1);
   for (int i = 0; i < s; i++)
   {
	   totalError.block<4,1>(4*i,0) = HSampsonError(h, X.row(i).transpose());
   }
   return totalError;
}

        //************************************************//
        
Eigen::MatrixXd HTotalSampsonErrorJacobian(const Eigen::Matrix<double,9,1> & h, const Eigen::MatrixXd & X)               
{                    
   int s  = X.rows();
   Eigen::MatrixXd totalGrad(4*s,9);
   for (int i = 0; i < s; i++)
   {
	   totalGrad.block<4,9>(4*i,0) = HSampsonErrorJacobian(h, X.row(i).transpose()); 
   }
   return totalGrad;
}

        //************************************************//
        
double HApproximateMSResidualError(const Eigen::Matrix<double,9,1> & h, const Eigen::MatrixXd & X)
{
	// Function to compute an approximation of the mean square residual 
	// error ( see section 5.1 of "Multiple View Geometry") by using the 
	// Sampson approximation. This is related to the reprojection error.
	//Input:
	//      _ h:= (9 x 1) vector for homography matrix
	//      _ X:= (N x 4) matrix where each row is a correspondence
   // Output: Approximate mean square residual error.
   //            
	int s = X.rows();
	double residual;
	Eigen::MatrixXd totalError = HTotalSampsonError(h, X);
	residual = (totalError.transpose()*totalError)(0);
    return residual/(4*s);
}

    //*********************************************************//
    
Eigen::Matrix <double,3,3> HMinimizeApproximateMSResidualError(Eigen::Matrix<double,3,3> Hinit,
                                             const Eigen::MatrixXd & X, int numIterations, std::string fileName = "output.txt")
{
	// Function minimizes the Approximate mean square residual error
	// by using the Levenberg-Marquardt algorithm
	// INPUT:
	//       _ Hinit:= initial guess for the homography matrix
	//       _ X := matrix of correspondences
	//       _ numIterations := number of iterations for the Levenberg-Marquardt algorithm
	// OUTPUT:
	//       _ H:= homography matrix
    	
	int s = X.rows();
	
	Eigen::Map<Eigen::MatrixXd> h(Hinit.transpose().data(), 9,1);
	std::cout << " The initial approximate mean square residual error: ";
	std::cout << HApproximateMSResidualError(h, X);
	std::cout << std::endl;
	Eigen::Matrix<double, 9, 9> I = Eigen::MatrixXd::Identity(9,9);
    Eigen::MatrixXd  totalGrad;  
    Eigen::MatrixXd totalError;
    Eigen::Matrix<double,9,9> Hessian; //aproximate hessian 
    Eigen::Matrix<double,9,9> A;
    Eigen::Matrix<double, 9,1> b;
    Eigen::Matrix<double,9,1> Delta;
    Eigen::Matrix<double, 9,1> h_trial;
    double Lambda;
    double cost;
    double previous_cost;
    int trial;
    
    
    std::ofstream myfile;
	myfile.open (fileName.c_str(), std::ios::out | std::ios::app);
	
	
	previous_cost = HApproximateMSResidualError(h, X);
    cost = previous_cost;                               
	                                      
	for (int k = 0; k < numIterations; k++)
	{
		trial = 0;
		
		totalError  = HTotalSampsonError(h,X);
		totalGrad = HTotalSampsonErrorJacobian(h, X);
		b = -totalGrad.transpose()*totalError/(2*s);
		Hessian = totalGrad.transpose()*totalGrad/(2*s);
		
		if (k == 0)
		{		
		    Lambda = 0;
		    for (int j = 0; j < 9; j++)
		    {
			   Lambda += Hessian(j,j);
		    }
	        Lambda = (10e-4)*Lambda/9.0;
	    }
	    
	    
	    while ((trial == 0) or (cost > previous_cost)) 
	    {
		    Lambda = 10*Lambda;
		    A = Hessian + Lambda*I;
		    
		    Delta = A.colPivHouseholderQr().solve(b);
		    h_trial = h + Delta;
		    cost = HApproximateMSResidualError(h_trial, X);
		    trial += 1;
		}  
	    h = h_trial;
	    Lambda = 0.1*Lambda;
	    previous_cost = cost;
	    
	    myfile << k << "	"<<  cost << "\n";
	     
	    
	}
	std::cout << "The final mean residual error: " << cost << std::endl; 
    myfile.close();
	
	
	//Reshaping 
    Eigen::Map<Eigen::MatrixXd> Ht(h.data(), 3,3);
           
    Eigen::Matrix<double,3,3> H = Ht.transpose();
    
        
    return H;
}

	//*********************************************************//

double EstimatedNoiseStandardDeviation(double MSResidualError, int n)
{
	// Function computes an estimated for the standard deviation of the noise.
	// It is assumed that the noise on each coordinate image is independent
	// and Gaussian with the same standard deviation
   // INPUT:
   //      _ MSResidualError:= mean square residual error (or an approximation)
   //      _ n := the number of correspondences (it is assumed n > 4)
   // OUTPUT: estimate for the standard deviation
   
   double estimated_variance = 2.0*n*MSResidualError/(n-4);
   
   return sqrt(estimated_variance);
}

     //*********************************************************//
std::vector<int> HRetrieveInliersIndex(const Eigen::MatrixXd & X, const Eigen::Matrix<double,9,1>  & h, double threshold)
{
		
	int s = X.rows();
    	                              
	int n_inlier; //integer to keep track of the number of inliers
	
	double cost;
	Eigen::Matrix<double, 4, 1> SampsonError;
	
	//For storing index 
	std::vector<int> vstore;
	vstore.reserve(s);
	
	//Counting the number of inliers
	for (int i = 0; i < s; i++)
	{  
	    SampsonError = HSampsonError(h, X.row(i).transpose());
		cost  = (SampsonError.transpose()*SampsonError)(0);
	    if (cost < threshold)
		{
		   n_inlier += 1;
			   vstore.push_back(i);
		 }
	}
	
	return vstore;
}
      //*******************************************//
      
Eigen::MatrixXd Retrieve(std::vector<int> v, const Eigen::MatrixXd & X)
{
    Eigen::MatrixXd Xstore(v.size(),4);
    
	for (int i  = 0; i < v.size(); i++)
	{
		Xstore.row(i) = X.row(v[i]);
	}
	return Xstore;
}
	
   //*************************************************//
   
std::vector<int> HRANSAC(const Eigen::MatrixXd & X, double p, double sigma, double epsilon = 0.05)
{
	//Function estimates the number of ransac samples for the homography
	//INPUT:
	//     _ X : matrix of correspondences
	//     _ p: probability that at least one of the chosen sample has no outliers
	//     _ sigma: estimate for the noise standard deviation per image coordinate
	//     _ epsilon : estimated proportion of outliers
	
	 
    int N; // number of RANSAC samples
    N = (int) round(log(1-p)/log(1.0 -pow((1-epsilon),4))); 
		

	int s = X.rows();
	Eigen::Matrix <double,4,4> Xstore;
    
    double threshold = 6.0*pow(sigma,2); 
    
    int minimumSize = (int) (1 - epsilon)*s;
		
	std::vector<int> v;
	v.reserve(s);
	std::vector<int>::iterator it;
	
	std::vector<int> v_inliers;
	v_inliers.reserve(s);
	
	std::vector<int> v_best;
	v_best.reserve(s);
	
			
	for (int i = 0; i < s; i++)
	{
		v.push_back(i);
	}
	
	Eigen::Matrix<double,3,3> H; //matrix to store the homography
	
	
	for (int k = 0; k < N ; k++)
	{   
		v_inliers.clear();	
		
		// Selecting 4 random correspondences
		std::srand(std::time(0));
		std::random_shuffle(v.begin(),v.end());
		it = v.begin();
		
		for (int i  = 0; i < 4; i++)
		{
			Xstore.row(i) = X.row(*it);
		    it += 1;
		}
		
		//Computing the corresponding homography
		H = DLT(Xstore);
		Eigen::Map<Eigen::MatrixXd> h(H.data(), 9,1);
		
		//Counting the number of inliers
		v_inliers = HRetrieveInliersIndex(X, h, threshold);
		
		if (v_inliers.size() > minimumSize)
		{
			return v_inliers;
		}
		
		else if (v_inliers.size() > v_best.size())
		{
			v_best.clear();
			v_best = v_inliers;
		}
			
    }
    
    std::cout << "All " << N << " RANSAC samples were executed." << std::endl;
    return v_best;
}
             //***********************************//
             
Eigen::Matrix<double,3,3> RobustRANSACSampson(const Eigen::MatrixXd & X, int numIterations, double sigma)
{
	Eigen::MatrixXd Xnorm(X.rows(),4);
    Eigen::Matrix <double, 3, 3> T;
    Eigen::Matrix <double, 3, 3> Tprime;
        
    //Normalizing and storing generated similarity transformations
    Normalize(X, Xnorm, T, Tprime);
    
	int s  = X.rows();
	double epsilon = 0.1;
	double p = 0.99; 
	
	
	std::vector<int> v_inliers = HRANSAC(Xnorm, p, sigma, epsilon);
	
	Eigen::MatrixXd Xinliers = Retrieve(v_inliers,Xnorm);
	
	Eigen::Matrix<double,3,3> Hnorm = DLT(Xinliers);  //initial guess DLT
	
	std::cout << "The Normalized DLT result: "<<  std::endl;
	
	Hnorm = Hnorm/Hnorm(2,2);
	
	std::cout << Hnorm << "\n\n";
	
	Eigen::Matrix<double,3,3> H = (Tprime.inverse())* Hnorm* T;
	
	Eigen::ComplexEigenSolver<Eigen::Matrix3d> eigensolver(H);
	if (eigensolver.info() != Eigen::Success) abort();
	std::cout << "The eigenvalues of H are:\n" << eigensolver.eigenvalues() << std::endl;
	std::cout << "The determinant is: "<< H.determinant() << std::endl;
	
	
    int n_inliersPrevious = v_inliers.size();  //original number of inliers
    int n_inliersCurrent = 0;
    
    double new_sigma;
      
    double threshold;
    
    double MSResidualError;            
	    
    while (n_inliersPrevious != n_inliersCurrent)
    {
		Hnorm = HMinimizeApproximateMSResidualError(Hnorm, Xinliers, numIterations);
					
        n_inliersPrevious = n_inliersCurrent;
        
        v_inliers.clear();
        
        Eigen::Map<Eigen::MatrixXd> h(Hnorm.data(), 9,1);
        
        MSResidualError = HApproximateMSResidualError(h, Xinliers);
        
        new_sigma = EstimatedNoiseStandardDeviation( MSResidualError, Xinliers.size());
        
        threshold = 11.0*pow(new_sigma,2); 
        
        v_inliers = HRetrieveInliersIndex(Xnorm, h, threshold);
		         
		Xinliers.resize(v_inliers.size(),4);
		Xinliers = Retrieve(v_inliers,Xnorm);
		n_inliersCurrent = v_inliers.size();
		std::cout << "The number of inliers: " << n_inliersCurrent << std::endl;
	 }
	 
	H = (Tprime.inverse())* Hnorm* T;
	
	return H/H(2,2);
}
		
    
        
        
          
	
	
	
	
	
	

	
	
	
	

	

#endif 

