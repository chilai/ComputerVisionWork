/*Implementation of algorithms for computing the fundamental matrix
for image reconstruction  */

#ifndef FMATRIX
#define FMATRIX

#include <iostream>
#include <vector>
#include <stdio.h>
#include <cstdlib>
#include <Eigen/Dense>
#include "preprocessing.hpp"
#include "optimizationAndApproximation.hpp"


// Function prototypes
Eigen::MatrixXd FundamentalAlgebraicErrorMatrix(const Eigen::MatrixXd & X);
Eigen::Matrix<double,3,3> The8PointAlgo(const Eigen::MatrixXd & X);
Eigen::Matrix<double,3,3> Normalized8Point(const Eigen::MatrixXd & X);
Eigen::Matrix<double,3,3> CrossProductMatrix(const Eigen::Matrix<double,3,1> & a);
void ComputeEpipoles(const Eigen::Matrix<double,3,3> & F, Eigen::Matrix<double,3,1> * epipoles);
Eigen::Matrix<double,3,3> AlgebraicMinimizationAlgo(Eigen::MatrixXd A, Eigen::Matrix<double,3,3> Finit);
Eigen::Matrix<double,9,1> AlgebraicMinimizationF(const Eigen::MatrixXd & A, const Eigen::Matrix<double,3,1> & e);
Eigen::Matrix<double,9,3> AlgebraicMinimizationFJacobian(const Eigen::MatrixXd & A, const Eigen::Matrix<double,3,1> & e, double epsilon);
void ComputeCanonicalCameraPairs(const Eigen::Matrix<double,3,3> & F, Eigen::Matrix<double,3,4> & P, Eigen::Matrix<double,3,4> & Pprime);


//**********************************************************************
Eigen::MatrixXd FundamentalAlgebraicErrorMatrix(const Eigen::MatrixXd & X)
{
	// Function computes the matrix that is used to compute the algebraic
	// error related to the fundamental matrix
	// INPUT:
	//     _X:= (N x 4) matrix where each row is a correspondence
	// OUTPUT:
	//      _ A := (N x 9) matrix to compute the algebraic error
	
	int s = X.rows();
    Eigen::MatrixXd A(s,9); 
    for (int i = 0; i < s; i++)
    {
		A.row(i) << X(i,2)*X(i,0), X(i,2)*X(i,1), X(i,2), X(i,3)*X(i,0),
		            X(i,3)*X(i,1), X(i,3), X(i,0), X(i,1), 1;
	}
	
	return A;
}	
	
           //****************************************//
           
Eigen::Matrix<double,3,3> The8PointAlgo(const Eigen::MatrixXd & X)
{
	// Function computes the fundamental matrix of a pair of cameras using
	// the  8-point algorithm
	// INPUT:
	//      _X := (N x 4) matrix where each row is a correspondence
	// OUTPUT: 
	//        _F := (3 x3) fundamental matrix
	
    
    //Matrix A that defines the algebraic cost function for the fundamental matrix
    Eigen::MatrixXd A = FundamentalAlgebraicErrorMatrix(X);
   
	//Computing the right singular vector corresponding to smallest 
    // singular value of A
    Eigen::JacobiSVD<Eigen::MatrixXd> svd(A, Eigen::ComputeFullV);
    Eigen::MatrixXd f = svd.matrixV().col(8);
    
    
    //Reshaping 
    Eigen::Map<Eigen::MatrixXd> Fpriort(f.data(), 3,3);
    
    Eigen::MatrixXd Fprior = Fpriort.transpose();
    
    //Enforcing the 'rank 2' constraint 
    Eigen::JacobiSVD<Eigen::MatrixXd> svd2(Fprior, Eigen::ComputeFullU | Eigen::ComputeFullV);
    Eigen::MatrixXd values = svd2.singularValues();
    Eigen::MatrixXd U = svd2.matrixU();
    Eigen::MatrixXd V = svd2.matrixV();
    
    Eigen::Matrix<double,3,3> D = Eigen::MatrixXd::Constant(3,3,0);
    for (int i = 0; i < 2; i++)
    {
		D(i,i) = values(i);
	}
		
	return U*D*V.transpose();
	
	   
} 
                 //*********************************//
                 
Eigen::Matrix<double,3,3> Normalized8Point(const Eigen::MatrixXd & X)
{
	// Function uses the 8-point algorithm after normalizing the set 
	// of correspondences
	
	Eigen::MatrixXd Xnorm(X.rows(),4);
    Eigen::Matrix <double, 3, 3> T;
    Eigen::Matrix <double, 3, 3> Tprime;
    
    //Normalizing and storing generated similarity transformations
    Normalize(X, Xnorm, T, Tprime);
    
    Eigen::Matrix<double,3,3> Fnorm = The8PointAlgo(Xnorm);
    
    return Tprime.transpose()*Fnorm*T;
    
}	
              //***********************************//

Eigen::Matrix<double,3,3> CrossProductMatrix(const Eigen::Matrix<double,3,1> & a)
{
	//Function generates skew-symmetric matrix generated by the cross product
	//with the input column vector a
	
	Eigen::Matrix<double,3,3> M;
	
	M << 0, -a(2), a(1),
	     a(2), 0, -a(0),
	     -a(1), a(0), 0;
	     
	return M;
}

void ComputeEpipoles(const Eigen::Matrix<double,3,3> & F, Eigen::Matrix<double,3,1> * epipoles)
{
	//Function computes the epipole for a fundamental matrix (in homogeneous coordinates)
	// INPUT:
	//      _F := 3x3 fundamental matrix of a pair of cameras
	//  
	//      _epipoles:= array where the epipoles are stored
    //	             epipoles[0] is the epipole of the first camera
    //               epipoles[1] is the epipole of the second camera
    
    Eigen::JacobiSVD<Eigen::MatrixXd> svd(F, Eigen::ComputeFullU | Eigen::ComputeFullV);
    Eigen::Matrix<double,3,1> e = svd.matrixV().rightCols(1);
    Eigen::Matrix<double,3,1> eprime = svd.matrixU().rightCols(1);
    
    epipoles[0] = e;
    epipoles[1] = eprime;
}


Eigen::Matrix<double,9,1> AlgebraicMinimizationF(const Eigen::MatrixXd & A, const Eigen::Matrix<double,3,1> & e)
{
	// Cost function that is minimized in the algebraic minimization algorithm 
	// using the Levenberg-Marquardt algorithm
	//INPUT:
	//     _ A:= (N x 9) matrix generated by the correspondences and is used 
	//           to compute the algebraic error vector for the fundamental matrix
	//     _ e:= (3x1) column vector representing the right epipole.
	//
	Eigen::Matrix<double,3,3> eCross =  CrossProductMatrix(e);
	Eigen::Matrix<double,9,9> E;
	E.block<3,3>(0,0) = eCross;
	E.block<3,3>(3,3) = eCross;
    E.block<3,3>(6,6) = eCross;	
	          
	Eigen::Matrix<double,9,1> f = LeastSquareGivenConstraint(A, E, 6);
	
	return f;
	
}

Eigen::Matrix<double,9,3> AlgebraicMinimizationFJacobian(const Eigen::MatrixXd & A, 
                                                         const Eigen::Matrix<double,3,1> & e, double epsilon)
{
	
	Eigen::Matrix<double,3,1> e_left = e;
	Eigen::Matrix<double,3,1> e_right = e;
	Eigen::Matrix<double,9,1> f_left;
	Eigen::Matrix<double,9,1> f_right;
	Eigen::Matrix<double,9,3> Jacobian;
	
	for (int i = 0; i < 3; i++)
	{
		e_left(i) -= epsilon;
		e_right(i) += epsilon;
		f_left =  AlgebraicMinimizationF(A,e_left);
		f_right = AlgebraicMinimizationF(A,e_right);
		
		Jacobian.col(i) = (f_right - f_left)/(2*epsilon);
		
		e_left(i) = e(i);
		e_right(i) = e(i);
	}
		
  return Jacobian;
 }
 
void ComputeCanonicalCameraPairs(const Eigen::Matrix<double,3,3> & F, Eigen::Matrix<double,3,4> & P, Eigen::Matrix<double,3,4> & Pprime)
{
	//Retrieve epipoles
	Eigen::Matrix<double,3,1> * epipoles;
	epipoles  = new Eigen::Matrix<double,3,1> [2];
	ComputeEpipoles(F, epipoles);
	
	//Construct the camera pairs
	P.block<3,3>(0,0) = Eigen::MatrixXd::Identity(3,3);
	P.col(3) =Eigen::MatrixXd::Constant(3,1,0);
	
    Pprime.block<3,3>(0,0) = (CrossProductMatrix(epipoles[1])) * F;
    Pprime.col(3) = epipoles[1];
    
    std::cout << "The right epipole is: " << std::endl;
    std::cout << epipoles[1] << "\n\n";
    
    delete [] epipoles;
}
    
    
    
    
     
	
	 
	
	


 
       
#endif


