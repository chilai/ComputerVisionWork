/*Implementation of algorithms for computing the fundamental matrix
for image reconstruction  */

#ifndef FMATRIX
#define FMATRIX

#include <iostream>
#include <vector>
#include <stdio.h>
#include <cstdlib>
#include <Eigen/Dense>
#include "preprocessing.hpp"
#include "optimizationAndApproximation.hpp"

// Function prototypes
Eigen::MatrixXd FundamentalAlgebraicErrorMatrix(const Eigen::MatrixXd & X);
Eigen::Matrix<double,3,3> The8PointAlgo(const Eigen::MatrixXd & X);
Eigen::Matrix<double,3,3> Normalized8Point(const Eigen::MatrixXd & X);
Eigen::Matrix<double,3,3> CrossProductMatrix(const Eigen::Matrix<double,3,1> & a);
void ComputeEpipoles(const Eigen::Matrix<double,3,3> & F, Eigen::Matrix<double,3,1> * epipoles);
double AlgebraicMinimizationCost(const Eigen::MatrixXd & A, const Eigen::Matrix<double,9,1> & f);
Eigen::Matrix<double,9,1> AlgebraicMinimizationF(const Eigen::MatrixXd & A, const Eigen::Matrix<double,3,1> & e);
Eigen::Matrix<double,9,3> AlgebraicMinimizationFJacobian(const Eigen::MatrixXd & A, const Eigen::Matrix<double,3,1> & e, double epsilon);
void ComputeCanonicalCameraPairs(const Eigen::Matrix<double,3,3> & F, Eigen::Matrix<double,3,4> & P, Eigen::Matrix<double,3,4> & Pprime);
Eigen::Matrix<double,3,3> AlgebraicMinimizationAlgo(const Eigen::MatrixXd & X, const  Eigen::Matrix<double,3,3> & Finit,
                                                     int numIterations, std::string fileName);

//**********************************************************************
Eigen::MatrixXd FundamentalAlgebraicErrorMatrix(const Eigen::MatrixXd & X)
{
	// Function computes the matrix that is used to compute the algebraic
	// error related to the fundamental matrix
	// INPUT:
	//     _X:= (N x 4) matrix where each row is a correspondence
	// OUTPUT:
	//      _ A := (N x 9) matrix to compute the algebraic error
	
	int s = X.rows();
    Eigen::MatrixXd A(s,9); 
    for (int i = 0; i < s; i++)
    {
		A.row(i) << X(i,2)*X(i,0), X(i,2)*X(i,1), X(i,2), X(i,3)*X(i,0),
		            X(i,3)*X(i,1), X(i,3), X(i,0), X(i,1), 1;
	}
	
	return A;
}	
	
           //****************************************//
           
Eigen::Matrix<double,3,3> The8PointAlgo(const Eigen::MatrixXd & X)
{
	// Function computes the fundamental matrix of a pair of cameras using
	// the  8-point algorithm
	// INPUT:
	//      _X := (N x 4) matrix where each row is a correspondence
	// OUTPUT: 
	//        _F := (3 x3) fundamental matrix
	
    
    //Matrix A that defines the algebraic cost function for the fundamental matrix
    Eigen::MatrixXd A = FundamentalAlgebraicErrorMatrix(X);
   
	//Computing the right singular vector corresponding to smallest 
    // singular value of A
    Eigen::JacobiSVD<Eigen::MatrixXd> svd(A, Eigen::ComputeFullV);
    Eigen::MatrixXd f = svd.matrixV().col(8);
    
    
    //Reshaping 
    Eigen::Map<Eigen::MatrixXd> Fpriort(f.data(), 3,3);
    
    Eigen::MatrixXd Fprior = Fpriort.transpose();
    
    //Enforcing the 'rank 2' constraint 
    Eigen::JacobiSVD<Eigen::MatrixXd> svd2(Fprior, Eigen::ComputeFullU | Eigen::ComputeFullV);
    Eigen::MatrixXd values = svd2.singularValues();
    Eigen::MatrixXd U = svd2.matrixU();
    Eigen::MatrixXd V = svd2.matrixV();
    
    Eigen::Matrix<double,3,3> D = Eigen::MatrixXd::Constant(3,3,0);
    for (int i = 0; i < 2; i++)
    {
		D(i,i) = values(i);
	}
		
	return U*D*V.transpose();
	
	   
} 
                 //*********************************//
                 
Eigen::Matrix<double,3,3> Normalized8Point(const Eigen::MatrixXd & X)
{
	// Function uses the 8-point algorithm after normalizing the set 
	// of correspondences
	
	Eigen::MatrixXd Xnorm(X.rows(),4);
    Eigen::Matrix <double, 3, 3> T;
    Eigen::Matrix <double, 3, 3> Tprime;
    
    //Normalizing and storing generated similarity transformations
    Normalize(X, Xnorm, T, Tprime);
    
    Eigen::Matrix<double,3,3> Fnorm = The8PointAlgo(Xnorm);
    
    return Tprime.transpose()*Fnorm*T;
    
}	
              //***********************************//

Eigen::Matrix<double,3,3> CrossProductMatrix(const Eigen::Matrix<double,3,1> & a)
{
	//Function generates skew-symmetric matrix generated by the cross product
	//with the input column vector a
	
	Eigen::Matrix<double,3,3> M;
	
	M << 0, -a(2), a(1),
	     a(2), 0, -a(0),
	     -a(1), a(0), 0;
	     
	return M;
}

            //**********************************************//

void ComputeEpipoles(const Eigen::Matrix<double,3,3> & F, Eigen::Matrix<double,3,1> * epipoles)
{
	//Function computes the epipole for a fundamental matrix (in homogeneous coordinates)
	// INPUT:
	//      _F := 3x3 fundamental matrix of a pair of cameras
	//  
	//      _epipoles:= array where the epipoles are stored
    //	             epipoles[0] is the epipole of the first camera
    //               epipoles[1] is the epipole of the second camera
    
    Eigen::JacobiSVD<Eigen::MatrixXd> svd(F, Eigen::ComputeFullU | Eigen::ComputeFullV);
    Eigen::Matrix<double,3,1> e = svd.matrixV().rightCols(1);
    Eigen::Matrix<double,3,1> eprime = svd.matrixU().rightCols(1);
    
    epipoles[0] = e;
    epipoles[1] = eprime;
}

                   //********************************************//
                   
double AlgebraicMinimizationCost(const Eigen::MatrixXd & A, const Eigen::Matrix<double,9,1> & f)
{
	// Function computes squared norm of algebraic error vector 
	//   errorVector = Af
	// INPUT: 
	//       _ A := (N x 9) matrix to compute the algebraic error vector
	//       _ f : = (9 x 1) column vector representing a fundamental matrix
	//
	// Output:  squared norm of error vector
                           
                      
    return  (f.transpose() * A.transpose() * A * f)(0);               
}                   
                   
                   
                   //*******************************************//
                   
Eigen::Matrix<double,9,1> AlgebraicMinimizationF(const Eigen::MatrixXd & A, const Eigen::Matrix<double,3,1> & e)
{
	// Cost function that is minimized in the algebraic minimization algorithm 
	// using the Levenberg-Marquardt algorithm
	// We are assuming a fundamental matrix of the form
	//        F = M[e]x 
	// where M is a nonsingular matrix and [e]x is any skew-symmetric matrix 
	// See Multiple View geometry Section 11.3
	//INPUT:
	//     _ A:= (N x 9) matrix generated by the correspondences and is used 
	//           to compute the algebraic error vector for the fundamental matrix
	//     _ e:= (3x1) column vector representing the epipole of the first image plane
	//OUTPUT:
	//      _ f:= (9 x 1) fundamental matrix in row major order that minimizes
	//           ||Af|| = 1 under the constraint ||f|| = 1 and f = Em
	//      where E and m are defined in terms of M and e (See Section 11.3) 
	Eigen::Matrix<double,3,3> eCross =  CrossProductMatrix(e);
	Eigen::Matrix<double,9,9> E = Eigen::MatrixXd::Constant(9,9,0);
	E.block<3,3>(0,0) = eCross;
	E.block<3,3>(3,3) = eCross;
    E.block<3,3>(6,6) = eCross;	
	          
	Eigen::Matrix<double,9,1> f = LeastSquareGivenConstraint(A, E, 6);
	
	return f;
	
}

                    //**************************************//
                    
Eigen::Matrix<double,9,3> AlgebraicMinimizationFJacobian(const Eigen::MatrixXd & A, 
                                                         const Eigen::Matrix<double,3,1> & e, double epsilon = 10e-7)
{
	// Function computes the Jacobian of the function AlgebraicMinimizationF 
	// with respect to vector e (which represent epiploe of first image plane)
	// INPUT:
	//        A:= (N x 9) matrix generated by the correspondences and is used 
	//             to compute the algebraic error vector for the fundamental matrix
	//        _ e:= (3x1) column vector representing the epipole of the first image plane
	//        _ epsilon: = parameter to compute the numerical Jacobian
	// OUTPUT:
	//        _ Jacobian: = (9 x 3) Jacobian matrix
	Eigen::Matrix<double,3,1> e_left = e;
	Eigen::Matrix<double,3,1> e_right = e;
	Eigen::Matrix<double,9,1> f_left;
	Eigen::Matrix<double,9,1> f_right;
	Eigen::Matrix<double,9,3> Jacobian;
	
	for (int i = 0; i < 3; i++)
	{
		e_left(i) -= epsilon;
		e_right(i) += epsilon;
		f_left =  AlgebraicMinimizationF(A,e_left);
		f_right = AlgebraicMinimizationF(A,e_right);
		
		Jacobian.col(i) = (f_right - f_left)/(2*epsilon);
		
		e_left(i) = e(i);
		e_right(i) = e(i);
	}
  
  return Jacobian;
 }
                //*****************************************//
                
Eigen::Matrix<double,3,3> AlgebraicMinimizationAlgo(const Eigen::MatrixXd & X, const  Eigen::Matrix<double,3,3> & Finit,
                                                    int numIterations, std::string fileName = "output.txt" )
{
    // Retrieving an initial value for the first image plane epipole
    Eigen::Matrix<double,3,1> * epipoles;
	epipoles  = new Eigen::Matrix<double,3,1> [2];
	ComputeEpipoles(Finit, epipoles);
	
	Eigen::Matrix<double,3,1> e = epipoles[0]; // initial guess for the epipole
	
		
		
	Eigen::MatrixXd A = FundamentalAlgebraicErrorMatrix(X);
	
	Eigen::Matrix<double,9,1> f; // storing the column vector for the fundamental matrix
	
	int s = X.rows();
	
	Eigen::MatrixXd errorVector(s,1);
	
	Eigen::MatrixXd Grad(s,3);         // Jacobian  for errorVector
	
	Eigen::Matrix<double,3,3>  Hessian;// approximate Hessian used in
	                                   // the Levenberg-Marquardt algorithm
	Eigen::Matrix<double, 3, 3> I = Eigen::MatrixXd::Identity(3,3);
	                                    
	Eigen::Matrix<double,3,3> M;
    Eigen::Matrix<double, 3,1> b;
    Eigen::Matrix<double,3,1> Delta;

    Eigen::Matrix<double,3,1> e_trial;   // to store value of trial run
    Eigen::Matrix<double,9,1> f_trial;
    double previous_cost; 
    double cost; 
    int trial;
    double Lambda;
    
    std::ofstream myfile;
	myfile.open (fileName.c_str(), std::ios::out | std::ios::app);
	
	f = AlgebraicMinimizationF(A, e);
	
	
	previous_cost = AlgebraicMinimizationCost(A,f);
	 
    cost = previous_cost; 
     
    std::cout << "The initial cost: " << cost << std::endl;                              
	                                      
	for (int k = 0; k < numIterations; k++)
	{
		trial = 0;
						
		errorVector = A * f;
		
		Grad = A* AlgebraicMinimizationFJacobian(A, e);
		
		b = -Grad.transpose() * errorVector;
		Hessian = Grad.transpose() * Grad;
		
		if (k == 0)
		{		
		    Lambda = 0;
		    for (int j = 0; j < 3; j++)
		    {
			   Lambda += Hessian(j,j);
		    }
	        Lambda = (10e-4)*Lambda/9.0;
	    }
	    
	    
	    while ((trial == 0) or (cost > previous_cost)) 
	    {
		    Lambda = 10*Lambda;
		    M = Hessian + Lambda*I;
		    
		    Delta = M.colPivHouseholderQr().solve(b);
		    e_trial = e + Delta;
		    f_trial = AlgebraicMinimizationF(A, e_trial);
		    cost = AlgebraicMinimizationCost(A,f_trial);
		    trial += 1;
		} 
		// Correcting sign of f_trial to ensure smooth variation of error function
		
	    e = e_trial;
	    f = f_trial;
	    Lambda = 0.1*Lambda;
	    previous_cost = cost;
	    std::cout << cost << "\n";
	    myfile << k << "	"<<  cost << "\n";
	     
	    
	}
	std::cout << "The final cost: " << cost << std::endl; 
    myfile.close();
    
    //Reshaping 
    Eigen::Map<Eigen::MatrixXd> Ft(f.data(), 3,3);
    
    delete [] epipoles;
    
    return Ft.transpose();
     
           
}                
          
                               
                
                //****************************************//
                
void ComputeCanonicalCameraPairs(const Eigen::Matrix<double,3,3> & F, Eigen::Matrix<double,3,4> & P, Eigen::Matrix<double,3,4> & Pprime)
{
	//Retrieve epipoles
	Eigen::Matrix<double,3,1> * epipoles;
	epipoles  = new Eigen::Matrix<double,3,1> [2];
	ComputeEpipoles(F, epipoles);
	
	//Construct the camera pairs
	P.block<3,3>(0,0) = Eigen::MatrixXd::Identity(3,3);
	P.col(3) =Eigen::MatrixXd::Constant(3,1,0);
	
    Pprime.block<3,3>(0,0) = (CrossProductMatrix(epipoles[1])) * F;
    Pprime.col(3) = epipoles[1];
    
    delete [] epipoles;
}
    
           //*****************************************//
              
    
    
     
	
	 
	
	


 
       
#endif


